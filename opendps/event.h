/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2017 Johan Kanflo (github.com/kanflo)
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * @file event.h
 * @brief Event Queue System for OpenDPS
 *
 * This module provides a simple event queue for asynchronous communication
 * between ISRs and the main application loop. Events are generated by
 * hardware interrupts (buttons, rotary encoder, UART, ADC) and processed
 * by the UI framework.
 *
 * ## Event Flow
 *
 * 1. ISR detects hardware event (button press, encoder rotation, etc.)
 * 2. ISR calls event_put() to add event to queue
 * 3. Main loop calls event_get() to retrieve events
 * 4. Events are dispatched to UI handlers via uui_handle_screen_event()
 *
 * ## Thread Safety
 *
 * The event queue is designed to be safe for ISR-to-mainloop communication:
 * - event_put() is called from ISRs with interrupts disabled
 * - event_get() is called from main loop with interrupts enabled
 * - The queue uses simple indices for lockless operation
 *
 * @see uui.h for event handling in the UI framework
 */

#ifndef __EVENT_H__
#define __EVENT_H__

/**
 * @brief Event types enumeration
 *
 * Defines all possible events that can be generated by the hardware
 * and processed by the application. Events are placed in a FIFO queue
 * and processed by the main loop.
 */
typedef enum {
    /** @brief No event (queue empty or polling) */
    event_none = 0,
    /** @brief M1 button pressed */
    event_button_m1,
    /** @brief M2 button pressed */
    event_button_m2,
    /** @brief Both M1 and M2 buttons pressed simultaneously */
    event_buttom_m1_and_m2,
    /** @brief SEL (select) button pressed */
    event_button_sel,
    /** @brief ENABLE button pressed (power on/off toggle) */
    event_button_enable,
    /** @brief Rotary encoder rotated counter-clockwise */
    event_rot_left,
    /** @brief Rotary encoder rotated clockwise */
    event_rot_right,
    /** @brief Rotary encoder rotated CCW with button held */
    event_rot_left_set,
    /** @brief Rotary encoder rotated CW with button held */
    event_rot_right_set,
    /** @brief Rotary encoder button pressed */
    event_rot_press,
    /** @brief UART data received (complete frame available) */
    event_uart_rx,
    /** @brief Over Current Protection triggered */
    event_ocp,
    /** @brief Over Voltage Protection triggered */
    event_ovp
} event_t;

/**
 * @brief Button press duration types
 *
 * Distinguishes between short and long button presses for
 * different actions (e.g., long press to enter settings).
 */
typedef enum {
    /** @brief Short button press (< threshold) */
    press_short = 0,
    /** @brief Long button press (>= threshold) */
    press_long,
} button_press_t;


/**
 * @brief Initialize the event queue system
 *
 * Clears the event queue and prepares it for use. Must be called
 * once during system initialization before any events are generated.
 */
void event_init(void);

/**
 * @brief Retrieve the next event from the queue
 *
 * Removes and returns the oldest event from the FIFO queue.
 * If the queue is empty, event_none is returned.
 *
 * @param[out] event Pointer to receive the event type
 * @param[out] data  Pointer to receive additional event data
 * @return true if an event was retrieved
 * @return false if the queue was empty (event set to event_none)
 *
 * @note Called from main loop, not from ISRs
 * @note The data field interpretation depends on event type:
 *       - For button events: button_press_t (short/long press)
 *       - For rotation events: number of detents
 *       - For protection events: trigger value
 */
bool event_get(event_t *event, uint8_t *data);

/**
 * @brief Add an event to the queue
 *
 * Places a new event at the end of the FIFO queue. If the queue
 * is full, the event is silently dropped.
 *
 * @param[in] event Event type to add
 * @param[in] data  Additional event data (interpretation depends on event type)
 * @return true if the event was added to the queue
 * @return false if the queue was full (event dropped)
 *
 * @note Safe to call from ISRs
 * @note Queue overflow indicates system is not processing events fast enough
 */
bool event_put(event_t event, uint8_t data);

#endif // __EVENT_H__
